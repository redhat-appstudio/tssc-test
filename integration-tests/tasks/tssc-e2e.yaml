---
apiVersion: tekton.dev/v1
kind: Task
metadata:
  name: tssc-e2e
spec:
  params:
    - name: ocp-login-command
      type: string
      description: Command to log in to the OpenShift cluster where the tests will be executed.
    - name: oci-container
      type: string
      description: The URI of the OCI container registry to store test artifacts.
    - name: job-spec
      type: string
      description: 'The job specification containing details of the test execution.'
    - name: tssc-test-image
      type: string
      description: 'The tssc test image containing the tssc test binary.'
    - name: testplan
      type: string
      description: 'Optional testplan.json content encoded in base64 format. If not provided, testplan will be downloaded from the repository.'
      default: ""
  volumes:
    - name: rhtap-cli-volume
      secret:
        secretName: rhtap-cli-install
    - name: konflux-test-infra-volume
      secret:
        secretName: konflux-test-infra
    - name: tssc-test-dir
      emptyDir: {}
  steps:
    - name: copy-tssc-test
      image: $(params.tssc-test-image)
      command: ['/bin/sh', '-c']
      args: ['cp -r /tssc-test/* /e2e-test && chmod -R +x /e2e-test/*']
      volumeMounts:
        - name: tssc-test-dir
          mountPath: /e2e-test
    - name: generate-testplan
      image: $(params.tssc-test-image)
      workingDir: /e2e-test
      volumeMounts:
        - name: tssc-test-dir
          mountPath: /e2e-test
      env:
        - name: JOB_SPEC
          value: '$(params.job-spec)'
        - name: TESTPLAN_PARAM
          value: '$(params.testplan)'
      script: |
        #!/usr/bin/env bash
        set -o errexit
        set -o nounset
        set -o pipefail

        echo "Printing JOB_SPEC"
        echo "--------------------------------"
        echo "$JOB_SPEC"
        echo "--------------------------------"

        # Check if testplan parameter is provided
        if [[ -n "$TESTPLAN_PARAM" ]]; then
          echo "Using provided testplan parameter (base64 encoded)"
          echo "Decoding base64 testplan and saving to testplan.json"
          echo "$TESTPLAN_PARAM" | base64 -d > testplan.json
        else
          echo "No testplan parameter provided, downloading from repository"
          GIT_REPO="$(jq -r '.git.repo // empty' <<< $JOB_SPEC)"
          REPO_ORG=$(jq -r '.git.source_repo_org' <<< $JOB_SPEC)
          BRANCH=$(jq -r '.git.source_repo_branch' <<< $JOB_SPEC)
          testplan_file_location="integration-tests/config/testplan.json"
          echo "downloading testplan.json from $REPO_ORG/$GIT_REPO/refs/heads/$BRANCH/$testplan_file_location"
          curl -o testplan.json https://raw.githubusercontent.com/$REPO_ORG/$GIT_REPO/refs/heads/$BRANCH/$testplan_file_location
        fi

        echo "Printing testplan.json file"
        echo "--------------------------------"
        cat testplan.json
        echo "--------------------------------"
    - name: run-tssc-e2e
      image: $(params.tssc-test-image)
      workingDir: /e2e-test
      onError: continue
      computeResources:
        limits:
          memory: 6Gi
        requests:
          cpu: 100m
          memory: 3Gi
      volumeMounts:
        - name: rhtap-cli-volume
          mountPath: /usr/local/rhtap-cli-install
        - name: tssc-test-dir
          mountPath: /e2e-test
      env:
        - name: JOB_SPEC
          value: '$(params.job-spec)'
      script: |
        #!/usr/bin/env bash
        set -o nounset
        set -o pipefail

        cat <<EOF > .env
        #!/bin/bash
        # shellcheck disable=SC2034

        export QUAY_REGISTRY_ORG="rhtap_qe"
        export ARTIFACTORY_REGISTRY_ORG="rhtap"
        export NEXUS_REGISTRY_ORG="rhtap"

        # ========================== GIT REPOSITORY ==========================
        # When using Github as git repository, set the following variables
        export GITHUB_ORGANIZATION="rhtap-rhdh-qe"

        # When using Bitbucket as git repository, set the following variables
        export BITBUCKET_WORKSPACE="rhtap-test"
        export BITBUCKET_PROJECT="RHTAP"

        # ========================== CI ======================================
        # When using Azure pipelines, set the following variables
        export AZURE_PROJECT="shared-public"
        EOF

        # Set CI_TEST_RUNNER_IMAGE if CI running for tssc-dev-multi-ci repo
        GIT_REPO="$(jq -r '.git.repo // empty' <<< $JOB_SPEC)"
        if [ "$GIT_REPO" = "tssc-dev-multi-ci" ]; then
          cat << EOF >> .env
        export CI_TEST_RUNNER_IMAGE="${CI_TEST_RUNNER_IMAGE:-$(echo "$JOB_SPEC" | jq -r '.container_image')}"
        EOF
        fi

        echo "Printing .env file"
        echo "--------------------------------"
        cat .env
        echo "--------------------------------"

        # Log into OpenShift
        $(params.ocp-login-command)

        source .env
        # Run tests and capture exit code
        TEST_EXIT_CODE=0
        FORCE_COLOR=false npm run test:e2e || TEST_EXIT_CODE=$?

        echo "Test execution completed with exit code: $TEST_EXIT_CODE"

        exit $TEST_EXIT_CODE
    - name: upload-test-results
      image: quay.io/konflux-qe-incubator/konflux-qe-tools:latest
      workingDir: /e2e-test
      volumeMounts:
        - name: tssc-test-dir
          mountPath: /e2e-test
        - name: konflux-test-infra-volume
          mountPath: /usr/local/konflux-test-infra
      env:
        - name: OCI_CONTAINER
          value: $(params.oci-container)
      script: |
        #!/bin/bash
        set -o errexit
        set -o nounset
        set -o pipefail

        # Configuration constants
        readonly REPORT_DIR="./playwright-report"
        readonly REPORT_FILE="$REPORT_DIR/index.html"
        readonly RENAMED_REPORT_FILE="$REPORT_DIR/report.html"
        readonly ANNOTATION_FILE="annotation.json"
        readonly MAX_PUSH_ATTEMPTS=5
        readonly RETRY_DELAY=5

        # Get the exit code from the previous step
        PREVIOUS_STEP_EXIT_CODE=$(cat $(steps.step-run-tssc-e2e.exitCode.path))

        echo "Starting test report collection"
        echo "Previous test step exit code: ${PREVIOUS_STEP_EXIT_CODE}"

        # Load OCI credentials from mounted secret
        load_oci_credentials() {
          echo "Loading OCI credentials"

          local creds_file="/usr/local/konflux-test-infra/oci-storage"
          if [[ ! -f "$creds_file" ]]; then
            echo "ERROR: Credentials file not found: $creds_file" >&2
            return 1
          fi

          OCI_STORAGE_USERNAME=$(jq -r '.["quay-username"]' "$creds_file")
          OCI_STORAGE_TOKEN=$(jq -r '.["quay-token"]' "$creds_file")

          if [[ "$OCI_STORAGE_USERNAME" == "null" || "$OCI_STORAGE_TOKEN" == "null" ]]; then
            echo "ERROR: Invalid credentials in $creds_file" >&2
            return 1
          fi
        }

        # Create OCI annotation file
        prepare_oci_annotations() {
          echo "Preparing OCI annotations"

          local manifests
          if ! manifests=$(oras manifest fetch "$OCI_CONTAINER" 2>/dev/null | jq .annotations); then
            echo "ERROR: Failed to fetch manifest from $OCI_CONTAINER" >&2
            return 1
          fi

          jq -n --argjson manifest "$manifests" '{"$manifest": $manifest}' > "$ANNOTATION_FILE"
          echo "Annotation file created: $ANNOTATION_FILE"
        }

        # Pull OCI container silently
        pull_oci_container() {
          echo "Pulling OCI container: $OCI_CONTAINER"
          oras pull "$OCI_CONTAINER" >/dev/null 2>&1
        }

        # Push artifacts with retry mechanism
        push_artifacts_with_retry() {
          echo "Pushing test artifacts to OCI registry"

          for attempt in $(seq 1 $MAX_PUSH_ATTEMPTS); do
            if oras push "$OCI_CONTAINER" \
                --username="$OCI_STORAGE_USERNAME" \
                --password="$OCI_STORAGE_TOKEN" \
                --annotation-file "$ANNOTATION_FILE" \
                playwright-report/:application/vnd.acme.rocket.docs.layer.v1+tar \
                tmp/project-configs.json:application/json; then
              echo "Test results uploaded successfully"
              return 0
            fi

            if [[ $attempt -lt $MAX_PUSH_ATTEMPTS ]]; then
              echo "Push attempt $attempt failed, retrying in ${RETRY_DELAY}s..."
              sleep $RETRY_DELAY
            fi
          done

          echo "ERROR: Failed to push artifacts after $MAX_PUSH_ATTEMPTS attempts" >&2
          return 1
        }

        prepare_report_for_upload() {
          echo "Preparing report for upload"

          # Show report directory contents for debugging
          echo "Report directory contents:"
          if ! ls -la "$REPORT_DIR" 2>/dev/null; then
            echo "WARNING: Could not list report directory contents"
            return 1
          fi

          # Verify source file exists before renaming
          if [[ ! -f "$REPORT_FILE" ]]; then
            echo "ERROR: Source report file not found: $REPORT_FILE" >&2
            return 1
          fi

          # Rename report file for Artifactory UI compatibility
          if ! mv "$REPORT_FILE" "$RENAMED_REPORT_FILE"; then
            echo "ERROR: Failed to rename report file" >&2
            return 1
          fi

          echo "Renamed report file to: $RENAMED_REPORT_FILE"
          return 0
        }

        # Execute upload workflow
        prepare_report_for_upload || exit 1
        load_oci_credentials || exit 1
        prepare_oci_annotations || exit 1
        pull_oci_container || exit 1
        push_artifacts_with_retry || exit 1

        echo "Report collection completed successfully"

        # Final step: if the tests failed, make this step fail too to preserve the overall task status
        if [[ "${PREVIOUS_STEP_EXIT_CODE}" != "0" ]]; then
          echo "Tests failed with exit code ${PREVIOUS_STEP_EXIT_CODE}, failing upload step to preserve task status"
          exit "${PREVIOUS_STEP_EXIT_CODE}"
        fi
